<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockJump</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.2/web3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        body {
            background: #16213e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            color: #FFFFFF;
        }
        #gameWrapper {
            display: flex;
            justify-content: center;
            align-items: stretch;
            width: 100%;
            max-width: 1450px;
            margin: 0 auto;
        }
        #gameCenter {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #highscoreSection {
            width: 300px;
            margin-right: 20px;
            background: rgba(22, 33, 62, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 20px rgba(63, 225, 176, 0.3);
            flex: 0.1;
            padding-right: 20px;
        }
        #gameContainer {
            position: relative;
            flex-grow: 4;
            flex: 2;
            width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #powerupSection {
            width: 180px;
            margin-left: 10px;
            flex-grow: 0.2;
            flex: 0.7;
            padding-left: 20px;
        }
        #highscoreTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 8px;
            font-size: 12px
        }
        #highscoreTable th {
            padding: 3px;
            text-align: left;
            color: #3FE1B0;
            font-size: 14px;
            text-transform: uppercase;
            border-bottom: 2px solid #3FE1B0;
        }
        #highscoreTable td {
            padding: 8px 5px;
            text-align: left;
            font-size: 12px;
            background: rgba(63, 225, 176, 0.1);
            transition: background 0.3s ease;
        }
        #highscoreTable tr:hover td {
            background: rgba(63, 225, 176, 0.2);
        }
        #highscoreTable tr td:first-child {
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        #highscoreTable tr td:last-child {
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .section-title {
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
            color: #FFD700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #gameCanvas {
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(63, 225, 176, 0.5);
            margin-top: 20px;
        }
        #floorCounter {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            text-align: center;
        }
        #startButton, #soundToggle {
            font-size: 24px;
            padding: 10px 20px;
            background-color: #3FE1B0;
            color: #16213e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            margin: 10px;
        }
        #startButton:hover, #soundToggle:hover {
            background-color: #ff6b6b;
            transform: scale(1.05);
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        #achievementPopup {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 215, 0, 0.8);
            color: #16213e;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            display: none;
        }
        #blockCounter {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            text-align: center;
        }
        #windIndicator {
            position: absolute;
            font-size: 64px;
            color: rgb(238, 0, 0);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 1000; /* Ensure it's above other elements */
        }
        .section-title {
            color: #3FE1B0;
            font-size: 20px;
            margin-bottom: 10px;
            text-align: center;
        }
        .powerup-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .powerup-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
        }
        .powerup-description {
            font-size: 14px;
        }
        .powerup-item.active {
            background-color: rgba(255, 215, 0, 0.3);
            border-radius: 5px;
        }
        .powerup-timer {
            font-weight: bold;
            color: #FFD700;
        }
        #highscoreTable {
            width: 100%;
            border-collapse: collapse;
        }
        #highscoreTable th, #highscoreTable td {
            color: #3FE1B0;
            border: 1px solid #e94560;
            border-bottom: 2px solid #3FE1B0;
            padding: 5px;
            text-align: center;
        }
        #nameForm {
            margin-top: 20px;
            display: none;
            width: 100%;
        }
        #nameInput {
            width: 90%;
            padding: 10px;
            margin-bottom: 10px;
            background-color: rgba(63, 225, 176, 0.1);
            border: 1px solid #3FE1B0;
            color: #FFFFFF;
            font-family: 'Orbitron', sans-serif;;
        }
        #submitScore {
            width: 100%;
            padding: 10px;
            background-color: #3FE1B0;
            color: #16213e;
            border: none;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="highscoreSection">
            <div class="section-title">Highscores</div>
            <table id="highscoreTable">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Tezos Marketcap</th>
                        <th>Blks</th>
                    </tr>
                </thead>
                <tbody id="highscoreBody"></tbody>
            </table>
            <form id="nameForm">
                <input type="text" id="nameInput" placeholder="Enter your name" maxlength="10" required>
                <button type="submit" id="submitScore">Submit Score</button>
            </form>
        </div>
        <div id="gameContainer">
            <div id="blockCounter">Blocks Climbed: 0</div>
            <div id="floorCounter">Tezos Marketcap: 0000000000</div>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="achievementPopup"></div>
            <div id="windIndicator"></div>
            <div id="controls">
                <button id="connectButton">Connect to MetaMask</button>
                <button id="purchaseTriesButton">Purchase Game Tries</button>
                <button id="getTriesButton">Get Game Tries</button>
                <button id="highscoresButton">Get Highscores</button>
                <button id="updateScoreButton">Update Highscore</button>
                <button id="start-game-button">Start Game</button>
                <p id="output"></p>
            </div>
        </div>
        <div id="powerupSection">
            <div class="section-title">Powerups</div>
            <!-- Powerup descriptions will be dynamically added here -->
        </div>
    </div>
    <script type="module" src="web3Integration.js"></script>
    <script type="module">
        import { initWeb3, purchaseGameTries, getGameTries, getHighscores, updateHighscore, useGameTry } from './web3Integration.js';

        const repoBaseUrl = 'https://raw.githubusercontent.com/Blindripper/blockjump/main/';
        const soundUrl = `${repoBaseUrl}sound/`;
        const picsUrl = `${repoBaseUrl}pics/`;

        const BLAST_POWERUP_DURATION = 30; 
        let lastTime = 0;
        const fixedDeltaTime = 1 / 60;
        let accumulator = 0;
        let canvas, ctx;
        let sprites = new Map();
        let blastEffectActive = false;
        let blastEffectTimer = 0;
        let blocksClimbed = 0;

        function updateBlockCounter() {
            document.getElementById('blockCounter').textContent = `Blocks Climbed: ${blocksClimbed}`;
        }

        const POWERUP_MESSAGE_DURATION = 1000;

        function showPowerupMessage(message) {
            const canvas = document.getElementById('gameCanvas');
            const canvasRect = canvas.getBoundingClientRect();
            const popup = document.createElement('div');
            popup.textContent = message;
            popup.style.position = 'absolute';
            popup.style.top = `${canvasRect.top + canvas.height / 2}px`;
            popup.style.left = `${canvasRect.left + canvas.width / 2}px`;
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.backgroundColor = 'rgba(255, 215, 0, 0.8)';
            popup.style.color = '#16213e';
            popup.style.padding = '10px 20px';
            popup.style.borderRadius = '5px';
            popup.style.fontFamily = 'Orbitron, sans-serif';
            popup.style.fontSize = '18px';
            popup.style.zIndex = '1000';
            popup.style.textAlign = 'center';
            popup.style.whiteSpace = 'nowrap';
            popup.style.pointerEvents = 'none';
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.style.transition = 'opacity 0.5s';
                popup.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(popup);
                }, 500);
            }, POWERUP_MESSAGE_DURATION);
        }

        let debugInfo = {
            totalBlocksClimbed: 0,
            blocksUntilNextPowerup: 0,
            powerupsGenerated: 0,
            activePowerups: 0
        };

        const powerupDescriptions = {
            bitcoin: { points: 250, effect: "Fly for 5 seconds" },
            solana: { points: 0, effect: "Game Over" },
            ethereum: { points: 250, effect: "Shrinks platforms for 5 seconds" },
            etherLink: { points: 1000, effect: "Instant boost to score" },
            greenTezos: { points: 250, effect: "Allows triple jump for 30 seconds" },
            blast: { points: 250, effect: `Auto-collect EtherLink for ${BLAST_POWERUP_DURATION}s` },
            mintTezos: { points: 250, effect: "Slows down game for 30 seconds" },
            tezosX: { points: 250, effect: "Sets off wind for 30 seconds" }
        };

        const powerupImages = {
            bitcoin: 'bitcoin.png',
            solana: 'solana.png',
            ethereum: 'ethereum1.png',
            etherLink: 'Etherlink.png',
            greenTezos: 'greenTezos.png',
            blast: 'blast.png',
            mintTezos: 'slowMotion.png',
            tezosX: 'TezosX1.png'
        };

        function loadSprite(name, fileName) {
            return new Promise((resolve, reject) => {
                const sprite = new Image();
                sprite.onload = () => {
                    console.log(`${name} sprite loaded successfully`);
                    resolve({ key: name, image: sprite });
                };
                sprite.onerror = () => {
                    console.error(`Failed to load ${name} sprite from ${picsUrl}${fileName}`);
                    reject(new Error(`Failed to load ${name} sprite`));
                };
                sprite.src = `${picsUrl}${fileName}`;
            });
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
                img.src = src;
            });
        }

        const backgrounds = Array.from({ length: 16 }, (_, i) => ({
            image: null,
            floorStart: i * 100,
            color: `hsl(${i * 20}, 70%, 20%)`
        }));

        Promise.all(backgrounds.map((bg, index) => 
            loadImage(`${picsUrl}bg${index + 1}.jpg`)
                .then(img => { bg.image = img; })
                .catch(error => { 
                    console.error(error);
                })
        )).then(() => {
            console.log("All background images loaded (or failed gracefully)");
        }).catch(error => {
            console.error("Error in background loading:", error);
        });

        const stageNames = [
            { name: "Athens", start: 0, end: 999 },
            { name: "Babylon", start: 1000, end: 1999 },
            { name: "Carthage", start: 2000, end: 2999 },
            { name: "Delphi", start: 3000, end: 3999 },
            { name: "Edo", start: 4000, end: 4999 },
            { name: "Florence", start: 5000, end: 5999 },
            { name: "Granada", start: 6000, end: 6999 },
            { name: "Hangzhou", start: 7000, end: 7999 },
            { name: "Ithaca", start: 8000, end: 8999 },
            { name: "Jakarta", start: 9000, end: 9999 },
            { name: "Kathmandu", start: 10000, end: 10999 },
            { name: "Lima", start: 11000, end: 11999 },
            { name: "Mumbai", start: 12000, end: 12999 },
            { name: "Nairobi", start: 13000, end: 13999 },
            { name: "Oxford", start: 14000, end: 14999 },
            { name: "Paris", start: 15000, end: Infinity }
        ];

        let currentStageName = "";
        let stageNameOpacity = 0;
        let stageNameTimer = 0;

        const JUMP_VELOCITY = -800;
        const GRAVITY = 2000;
        let PLATFORM_SPEED = 50;

        let player = {
            x: 375,
            y: 530,
            width: 50,
            height: 50,
            speed: 500,
            velocityY: 0,
            velocityX: 0,
            isJumping: false,
            jumpCount: 0,
            maxJumps: 2,
            canJump: true
        };

        let platforms = [];
        let bottomPlatform = {
            x: 0,
            y: 580,
            width: 800,
            height: 20,
            isSafe: true
        };
        let score = 0;
        let keys = {};
        let gameRunning = false;
        let gameOver = false;
        let hasLeftGround = false;
        let currentBackgroundIndex = 0;
        let fadeAlpha = 0;
        let isFading = false;
        let nextBottomPlatformScore = 100;
        let isPlayerOnSafePlatform = false;

        let comboCounter = 0;
        let comboTimer = 0;
        let movingPlatforms = [];
        let wind = { speed: 0, direction: 1 };
        let achievements = {
            highJumper: { achieved: false, requirement: 10000 },
            comboMaster: { achieved: false, requirement: 10 },
            cryptoWhale: { achieved: false, requirement: 100000 }
        };

        let powerups = [];
        let powerupActive = false;
        let powerupTimer = 0;
        let blocksUntilNextPowerup = Math.floor(Math.random() * 10) + 5;
        let ethereumEffectActive = false;
        let ethereumEffectTimer = 0;
        let originalPlatformWidth = 120;
        let spikeBlockProbability = 0.05;
        let tezosXEffectActive = false;
        let tezosXEffectTimer = 0;
        
        const powerUpTypes = ['bitcoin', 'solana', 'ethereum', 'etherLink', 'greenTezos', 'blast', 'mintTezos', 'tezosX'];
        const TEZOSX_EFFECT_DURATION = 30;

        async function startGame() {
            console.log('Starting game...');
            try {
                const tries = await getGameTries();
                console.log('Current game tries:', tries);
                if (tries > 0) {
                    console.log('Using a game try...');
                    if (await useGameTry()) {
                        console.log('Game try used successfully. Resetting game...');
                        resetGame();
                        console.log('Game reset. Setting gameRunning to true...');
                        gameRunning = true;
                        lastTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    } else {
                        console.log('Failed to use a game try');
                    }
                } else {
                    console.log('No more tries left. Please purchase more.');
                }
            } catch (error) {
                console.error('Error starting game:', error);
            }
            console.log('End of startGame function. gameRunning:', gameRunning);
        }   

        if (gameRunning) {
            console.log('Starting game loop');
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(currentTime) {
            console.log('Game loop running, time:', currentTime);
            
            if (gameRunning) {
                let dt = (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                console.log('Updating game state');
                update(dt);
                
                console.log('Drawing game');
                draw();

                requestAnimationFrame(gameLoop);
            } else {
                console.log('Game is not running');
            }
        }

        const sounds = {
            jump: new Audio(`${soundUrl}jump.wav`),
            powerup: new Audio(`${soundUrl}powerup.mp3`),
            gameOver: new Audio(`${soundUrl}gameover.mp3`),
            background: new Audio(`${soundUrl}main.mp3`)
        };

        let isSoundOn = true;

        function toggleSound() {
            isSoundOn = !isSoundOn;
            document.getElementById('soundToggle').textContent = `Sound: ${isSoundOn ? 'On' : 'Off'}`;
            if (isSoundOn) {
                sounds.background.play();
            } else {
                sounds.background.pause();
            }
        }

        function playSound(soundName) {
            if (isSoundOn && sounds[soundName]) {
                sounds[soundName].currentTime = 0;
                sounds[soundName].play().catch(error => console.error("Error playing sound:", error));
            }
        }

        function startBackgroundMusic() {
            if (isSoundOn) {
                sounds.background.loop = true;
                sounds.background.play().catch(error => console.error("Error playing background music:", error));
            }
        }

        function stopBackgroundMusic() {
            sounds.background.pause();
            sounds.background.currentTime = 0;
        }

        function preloadSounds() {
            return Promise.all(Object.values(sounds).map(audio => {
                return new Promise((resolve, reject) => {
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    audio.addEventListener('error', reject);
                    audio.load();
                });
            }));
        }

        function updatePowerupDisplay(type, duration) {
            const powerupItem = document.getElementById(`powerup-${type}`);
            if (powerupItem) {
                powerupItem.classList.add('active');
                const timerElement = powerupItem.querySelector('.powerup-timer');
                
                let timeLeft = duration;
                const timerInterval = setInterval(() => {
                    timeLeft -= 0.1;
                    timerElement.textContent = `Time left: ${timeLeft.toFixed(1)}s`;
                    
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        powerupItem.classList.remove('active');
                        timerElement.textContent = '';
                    }
                }, 100);

                const clearTimer = () => {
                    clearInterval(timerInterval);
                    powerupItem.classList.remove('active');
                    timerElement.textContent = '';
                };

                document.addEventListener('gameOver', clearTimer, { once: true });
                document.addEventListener('gameReset', clearTimer, { once: true });
            }
        }

        let particles = [];

        function Particle(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = Math.random() * 2 - 1;
            this.vy = Math.random() * -2 - 1;
            this.alpha = 1;
            this.color = color;
        }

        Particle.prototype.update = function(dt) {
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= dt * 2;
        };

        Particle.prototype.draw = function(ctx) {
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, 2, 2);
            ctx.globalAlpha = 1;
        };

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function updatePowerups(dt) {
            const powerupFallSpeed = PLATFORM_SPEED * 2.5;
            
            for (let i = powerups.length - 1; i >= 0; i--) {
                powerups[i].y += powerupFallSpeed * dt;

                if (checkCollision(player, powerups[i])) {
                    applyPowerUpEffect(powerups[i].type);
                    createParticles(powerups[i].x, powerups[i].y, 10, '#3FE1B0');
                    powerups.splice(i, 1);
                    incrementCombo();
                } else if (powerups[i].y > canvas.height) {
                    powerups.splice(i, 1);
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].alpha <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function updateCombo(dt) {
            if (comboTimer > 0) {
                comboTimer -= dt;
                if (comboTimer <= 0) {
                    comboCounter = 0;
                }
            }
        }

        function updateWind(dt) {
            if (tezosXEffectActive) {
                wind.speed = 50;
                wind.direction = Math.random() < 0.5 ? -1 : 1;
            } else {
                if (Math.random() < 0.01) {
                    wind.speed = Math.random() * 50;
                    wind.direction = Math.random() < 0.5 ? -1 : 1;
                }
            }

            player.x += wind.speed * wind.direction * dt;
            player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
            updateWindIndicator();
        }

        function updateAchievements() {
            if (!achievements.highJumper.achieved && score >= achievements.highJumper.requirement) {
                achievements.highJumper.achieved = true;
                showAchievement("High Jumper");
            }
            if (!achievements.comboMaster.achieved && comboCounter >= achievements.comboMaster.requirement) {
                achievements.comboMaster.achieved = true;
                showAchievement("Combo Master");
            }
            if (!achievements.cryptoWhale.achieved && score >= achievements.cryptoWhale.requirement) {
                achievements.cryptoWhale.achieved = true;
                showAchievement("Crypto Whale");
            }
        }

        function showAchievement(name) {
            const achievementPopup = document.getElementById('achievementPopup');
            if (achievementPopup) {
                achievementPopup.textContent = `Achievement Unlocked: ${name}`;
                achievementPopup.style.display = 'block';
                setTimeout(() => {
                    achievementPopup.style.display = 'none';
                }, 3000);
            } else {
                console.error('Achievement popup element not found');
            }
        }

        function incrementCombo() {
            comboCounter++;
            comboTimer = 5;
            if (comboCounter > 1) {
                score += comboCounter * 10;
            }
        }

        function drawParticles(ctx) {
            particles.forEach(particle => particle.draw(ctx));
        }

        function applyPowerUpEffect(powerupType) {
            let message = '';
            let duration = 0;
            
            switch (powerupType) {
                case 'bitcoin':
                    powerupActive = true;
                    powerupTimer = 5;
                    duration = 5;
                    player.velocityY = JUMP_VELOCITY * 1.5;
                    message = 'Bitcoin: Fly 5s!';
                    break;
                case 'blast':
                    blastEffectActive = true;
                    blastEffectTimer = BLAST_POWERUP_DURATION;
                    duration = BLAST_POWERUP_DURATION;
                    message = `Blast: Auto-collecting EtherLink for ${BLAST_POWERUP_DURATION}s!`;
                    break;
                case 'ethereum':
                    ethereumEffectActive = true;
                    ethereumEffectTimer = 5;
                    duration = 5;
                    platforms.forEach(platform => {
                        platform.width *= 0.5;
                    });
                    message = 'Ethereum: Shrunk 5s';
                    break;
                case 'greenTezos':
                    player.maxJumps = 3;
                    duration = 30;
                    setTimeout(() => { player.maxJumps = 2; }, 10000);
                    message = 'Green Tezos: TripleJump 30s!';
                    break;
                case 'solana':
                    gameOver = true;
                    gameRunning = false;
                    playSound('gameOver');
                    message = 'Solana: Game Over!';
                    break;
                case 'mintTezos':
                    PLATFORM_SPEED *= 0.5;
                    duration = 30;
                    setTimeout(() => { PLATFORM_SPEED *= 2; }, 10000);
                    message = 'Mint Tezos: Slowdown 30s!';
                    break;
                case 'etherLink':
                    score += 1000;
                    message = 'EtherLink: +1000!';
                    updatePowerupDisplay(powerupType, 1);
                    break;
                case 'tezosX':
                    tezosXEffectActive = true;
                    tezosXEffectTimer = TEZOSX_EFFECT_DURATION;
                    duration = TEZOSX_EFFECT_DURATION;
                    message = 'TezosX: No Wind 30s!';
                    break;
            }
            
            if (duration > 0) {
                updatePowerupDisplay(powerupType, duration);
            }
            
            playSound('powerup');
            score += powerupDescriptions[powerupType].points;
            showPowerupMessage(message);
        }

        function handleBlastEffect() {
            const blastRadius = 200;
            let collectedCount = 0;

            for (let i = powerups.length - 1; i >= 0; i--) {
                if (powerups[i].type === 'etherLink') {
                    const dx = powerups[i].x - (player.x + player.width / 2);
                    const dy = powerups[i].y - (player.y + player.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= blastRadius) {
                        score += powerupDescriptions['etherLink'].points;
                        createParticles(powerups[i].x, powerups[i].y, 10, '#3FE1B0');
                        powerups.splice(i, 1);
                        collectedCount++;
                    }
                }
            }

            if (collectedCount > 0) {
                showPowerupMessage(`Collected ${collectedCount} EtherLink${collectedCount > 1 ? 's' : ''}!`);
            }
        }

        let screenShake = {
            intensity: 0,
            duration: 0
        };

        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake(dt) {
            if (screenShake.duration > 0) {
                screenShake.duration -= dt;
                if (screenShake.duration <= 0) {
                    screenShake.intensity = 0;
                }
            }
        }

        function applyScreenShake(ctx) {
            if (screenShake.intensity > 0) {
                const dx = Math.random() * screenShake.intensity * 2 - screenShake.intensity;
                const dy = Math.random() * screenShake.intensity * 2 - screenShake.intensity;
                ctx.save();
                ctx.translate(dx, dy);
            }
        }

        function resetScreenShake(ctx) {
            if (screenShake.intensity > 0) {
                ctx.restore();
            }
        }

        async function endGame(finalScore) {
            try {
                await updateHighscore(finalScore);
                const highscores = await getHighscores();
                updateHighscoreTable(highscores);
                showNameForm();
            } catch (error) {
                console.error('Error ending game:', error);
                alert('Error updating highscore. Your score may not have been saved.');
                showNameForm();  
            }
        }

        let difficultyLevel = 1;
        let scoreThreshold = 2500;
        const maxDifficultyLevel = 10;

        function updateDifficulty() {
            const newDifficultyLevel = Math.floor(score / 2000) + 1;
            if (newDifficultyLevel > difficultyLevel) {
                difficultyLevel = newDifficultyLevel;
                adjustGameParameters();
                console.log(`Difficulty increased to level ${difficultyLevel}. New platform speed: ${PLATFORM_SPEED}`);
            }
        }

        function adjustGameParameters() {
            PLATFORM_SPEED = 50 + (difficultyLevel - 1) * 5;
            player.speed = 500 + (difficultyLevel - 1) * 10;
            let platformWidthReduction = Math.min(40, (difficultyLevel - 1) * 5);
            originalPlatformWidth = Math.max(80, 120 - platformWidthReduction);
            blocksUntilNextPowerup = Math.max(5, 15 - (difficultyLevel - 1));
            spikeBlockProbability = Math.min(0.15, 0.05 + (difficultyLevel - 1) * 0.01);

            if (difficultyLevel >= 3 && movingPlatforms.length < 2) {
                movingPlatforms.push({
                    x: Math.random() * (canvas.width - 100),
                    y: Math.random() * (canvas.height / 2),
                    width: 100,
                    height: 15,
                    speed: 50 + Math.random() * 50
                });
            }

            if (difficultyLevel >= 5) {
                wind.speed = Math.random() * (50 + difficultyLevel * 5);
            }
        }

        function createPlatform(y) {
            if (!canvas) {
                console.error('Canvas not initialized in createPlatform');
                return null;
            }
            let platformType = Math.random();
            let platform = {
                x: Math.random() * (canvas.width - (ethereumEffectActive ? originalPlatformWidth * 0.5 : originalPlatformWidth)),
                y: y,
                width: ethereumEffectActive ? originalPlatformWidth * 0.5 : originalPlatformWidth,
                height: 15,
                isGolden: (score + platforms.length) % 15 === 0
            };

            if (platformType < spikeBlockProbability) {
                platform.isSpike = true;
            }

            return platform;
        }

        function createPowerup(y) {
            if (!canvas) {
                console.error('Canvas not initialized in createPowerup');
                return null;
            }
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            debugInfo.powerupsGenerated++;
            console.log(`Powerup generated. Total: ${debugInfo.powerupsGenerated}, Type: ${type}`);
            return {
                x: Math.random() * (canvas.width - 30),
                y: y,
                width: 30,
                height: 30,
                type: type
            };
        }

        function initGame() {
            console.log('Initializing game...');
            if (!canvas || !ctx) {
                console.error('Canvas or context not available at start of initGame');
                return;
            }
            if (!ctx) {
                console.error('Context not available at start of initGame');
                return;
            }
            console.log('Canvas dimensions in initGame:', canvas.width, 'x', canvas.height);

            updateWindIndicator();
            platforms = [];
            for (let i = 0; i < 7; i++) {
                platforms.push(createPlatform(canvas.height - (i + 2) * 100));
            }
            nextBottomPlatformScore = 100;
            bottomPlatform.isSafe = true;
            isPlayerOnSafePlatform = false;
            gameRunning = true;
            gameOver = false 

            blastEffectActive = false;
            blastEffectTimer = 0;
            startBackgroundMusic();
        }

        function updateBackground() {
            let newBackgroundIndex = Math.min(Math.floor(score / 1000), backgrounds.length - 1);
            if (newBackgroundIndex !== currentBackgroundIndex) {
                currentBackgroundIndex = newBackgroundIndex;
                isFading = true;
                fadeAlpha = 0;
                updateStageName();
            }
        }

        gameRunning = false;
        gameOver = false;

        function updateStageName() {
            const currentStage = stageNames.find(stage => score >= stage.start && score <= stage.end) || stageNames[stageNames.length - 1];
            if (currentStage && currentStage.name !== currentStageName) {
                currentStageName = currentStage.name;
                stageNameOpacity = 1;
                stageNameTimer = 3;
            }
        }

        function update(dt) {
            console.log('Updating game state, dt:', dt);
            console.log('Player position:', player.x, player.y);
            console.log('Update function called, dt:', dt);
            if (!gameRunning || gameOver) return;
            
            updateWindIndicator();

            if (blastEffectActive) {
                blastEffectTimer -= dt;
                if (blastEffectTimer <= 0) {
                    blastEffectActive = false;
                    blastEffectTimer = 0;
                } else {
                    handleBlastEffect();
                }
            }

            if (tezosXEffectActive) {
                tezosXEffectTimer -= dt;
                if (tezosXEffectTimer <= 0) {
                    tezosXEffectActive = false;
                    tezosXEffectTimer = 0;
                }
            }

            if (debugInfo.totalBlocksClimbed > 10000) {
                console.error("Game loop safety limit reached");
                gameOver = true;
                gameRunning = false;
                return;
            }

            updateDifficulty();
            updateScreenShake(dt);
            updateParticles(dt);
            updateCombo(dt);
            updateWind(dt);
            updateAchievements();
            updatePowerups(dt);

            if (stageNameTimer > 0) {
                stageNameTimer -= dt;
                if (stageNameTimer <= 0) {
                    stageNameOpacity = Math.max(0, stageNameOpacity - dt);
                }
            }

            let moveSpeed = player.speed;

            if (keys.ArrowLeft) {
                player.velocityX = -moveSpeed;
            } else if (keys.ArrowRight) {
                player.velocityX = moveSpeed;
            } else {
                player.velocityX = 0;
            }

            player.x += player.velocityX * dt;
            player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

            if (keys.ArrowUp && player.jumpCount < player.maxJumps && player.canJump) {
                player.velocityY = JUMP_VELOCITY;
                player.isJumping = true;
                player.jumpCount++;
                player.canJump = false;
                if (!hasLeftGround) {
                    hasLeftGround = true;
                }
                if (isPlayerOnSafePlatform) {
                    isPlayerOnSafePlatform = false;
                }
                createParticles(player.x + player.width / 2, player.y + player.height, 10, '#3FE1B0');
                playSound('jump');
            }

            if (!keys.ArrowUp) {
                player.canJump = true;
            }

            if (powerupActive && keys.ArrowUp && player.canJump) {
                player.velocityY = JUMP_VELOCITY;
                player.canJump = false;
                if (!hasLeftGround) {
                    hasLeftGround = true;
                }
                if (isPlayerOnSafePlatform) {
                    isPlayerOnSafePlatform = false;
                }
                createParticles(player.x + player.width / 2, player.y + player.height, 10, '#3FE1B0');
                playSound('jump');
            }

            player.velocityY += GRAVITY * dt;
            player.y += player.velocityY * dt;

            let onPlatform = false;
            if (player.velocityY >= 0) {
                if (player.y + player.height > bottomPlatform.y && 
                    player.y + player.height < bottomPlatform.y + bottomPlatform.height &&
                    bottomPlatform.y < canvas.height) {
                    player.y = bottomPlatform.y - player.height;
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.jumpCount = 0;
                    if (bottomPlatform.isSafe) {
                        isPlayerOnSafePlatform = true;
                    }
                    createParticles(player.x + player.width / 2, player.y + player.height, 5, '#3FE1B0');
                    onPlatform = true;
                }

                platforms.forEach(platform => {
                    if (player.y + player.height > platform.y &&
                        player.y + player.height < platform.y + platform.height &&
                        player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x) {
                        if (platform.isSpike) {
                            gameOver = true;
                            gameRunning = false;
                            playSound('gameOver');
                        } else {
                            player.y = platform.y - player.height;
                            player.velocityY = 0;
                            player.isJumping = false;
                            player.jumpCount = 0;
                            onPlatform = true;

                            if (platform.isGolden) {
                                player.velocityY = JUMP_VELOCITY * 1.5;
                                score += 15;
                                triggerScreenShake(5, 0.3);
                                createParticles(player.x + player.width / 2, player.y + player.height, 15, '#3FE1B0');
                                playSound('powerup');
                            } else {
                                createParticles(player.x + player.width / 2, player.y + player.height, 15, '#3FE1B0');
                            }
                        }
                    }
                });

                movingPlatforms.forEach(platform => {
                    if (player.y + player.height > platform.y &&
                        player.y + player.height < platform.y + platform.height &&
                        player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.isJumping = false;
                        player.jumpCount = 0;
                        onPlatform = true;
                        createParticles(player.x + player.width / 2, player.y + player.height, 5, '#3FE1B0');
                    }
                });
            }

            if (!onPlatform) {
                player.isJumping = true;
            }

            if (hasLeftGround && !isPlayerOnSafePlatform) {
                platforms.forEach((platform, index) => {
                    platform.y += PLATFORM_SPEED * dt;
                    
                    if (platform.y > canvas.height) {
                        score++;
                        blocksClimbed++;
                        updateBlockCounter();
                        debugInfo.totalBlocksClimbed++;
                        document.getElementById('floorCounter').textContent = `Tezos Marketcap: ${score.toString().padStart(10, '0')}`;
                        platforms[index] = createPlatform(0);
                        
                        updateBackground();

                        if (debugInfo.totalBlocksClimbed >= blocksUntilNextPowerup) {
                            powerups.push(createPowerup(0));
                            blocksUntilNextPowerup = debugInfo.totalBlocksClimbed + Math.floor(Math.random() * 10) + 5;
                            console.log(`Powerup generated. Next at ${blocksUntilNextPowerup}`);
                        }
                    }
                });

                bottomPlatform.y += PLATFORM_SPEED * dt;

                if (score >= nextBottomPlatformScore) {
                    bottomPlatform = {
                        x: 0,
                        y: 0,
                        width: 800,
                        height: 20,
                        isSafe: true
                    };
                    nextBottomPlatformScore += 100;
                }

                movingPlatforms.forEach(platform => {
                    platform.x += platform.speed * dt;
                    platform.y += PLATFORM_SPEED * dt;
                    if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                        platform.speed *= -1;
                    }
                    if (platform.y > canvas.height) {
                        platform.y = 0;
                        platform.x = Math.random() * (canvas.width - platform.width);
                    }
                });
            }

            if (player.y < 300 && !isPlayerOnSafePlatform) {
                let diff = 300 - player.y;
                player.y = 300;
                platforms.forEach(platform => {
                    platform.y += diff;
                });
                movingPlatforms.forEach(platform => {
                    platform.y += diff;
                });
                bottomPlatform.y += diff;
            }

            if (player.y > canvas.height) {
                if (!bottomPlatform.isSafe || player.y > bottomPlatform.y + bottomPlatform.height) {
                    gameOver = true;
                    gameRunning = false;
                    playSound('gameOver');
                    endGame(score); 
                }
            }

            if (player.y + player.height < bottomPlatform.y) {
                bottomPlatform.isSafe = false;
                isPlayerOnSafePlatform = false;
            }

            player.x += wind.speed * wind.direction * dt;
            player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

            if (powerupActive) {
                powerupTimer -= dt;
                if (powerupTimer <= 0) {
                    powerupActive = false;
                }
            }

            if (ethereumEffectActive) {
                ethereumEffectTimer -= dt;
                if (ethereumEffectTimer <= 0) {
                    ethereumEffectActive = false;
                    platforms.forEach(platform => {
                        platform.width = originalPlatformWidth;
                    });
                }
            }

            updateWindIndicator();

            console.log(`Debug: Blocks: ${debugInfo.totalBlocksClimbed}, Powerups: ${powerups.length}, Difficulty: ${difficultyLevel}`);
        }

        function draw() {
            console.log('Drawing frame');
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 0, 50, 50);
            if (!ctx) {
                console.error('Canvas context not initialized in draw');
                return;
            }
            applyScreenShake(ctx);

            const currentBg = backgrounds[currentBackgroundIndex];
            const playerSprite = sprites.get('player');
            if (currentBg.image && currentBg.image.complete && currentBg.image.naturalHeight !== 0) {
                ctx.drawImage(currentBg.image, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = currentBg.color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            if (playerSprite && playerSprite.complete && playerSprite.naturalHeight !== 0) {
                if (powerupActive) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'rgba(63, 225, 176, 0.5)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.restore();
                }
                ctx.drawImage(playerSprite, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = powerupActive ? '#3FE1B0' : '#FFFFFF';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            if (stageNameOpacity > 0) {
                ctx.globalAlpha = stageNameOpacity;
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 48px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(currentStageName, canvas.width / 2, canvas.height / 2);
                ctx.globalAlpha = 1;
            }

            if (playerSprite && playerSprite.complete && playerSprite.naturalHeight !== 0) {
                if (powerupActive) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'rgba(63, 225, 176, 0.5)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.restore();
                }
                ctx.drawImage(playerSprite, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = powerupActive ? '#3FE1B0' : '#FFFFFF';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            if (isFading) {
                ctx.globalAlpha = fadeAlpha;
                const nextBg = backgrounds[Math.min(currentBackgroundIndex + 1, backgrounds.length - 1)];
                if (nextBg.image && nextBg.image.complete && nextBg.image.naturalHeight !== 0) {
                    ctx.drawImage(nextBg.image, 0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = nextBg.color;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                ctx.globalAlpha = 1;
                
                fadeAlpha += 0.02;
                if (fadeAlpha >= 1) {
                    isFading = false;
                }
            }

            if (gameOver) {
                document.dispatchEvent(new Event('gameOver'));
                drawGameOver();
            } else {
                ctx.fillStyle = bottomPlatform.isSafe ? '#4CAF50' : '#0f3460';
                ctx.fillRect(bottomPlatform.x, bottomPlatform.y, bottomPlatform.width, bottomPlatform.height);

                platforms.forEach(platform => {
                    if (platform.isSpike) {
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(platform.x, platform.y + platform.height);
                        ctx.lineTo(platform.x + platform.width / 2, platform.y);
                        ctx.lineTo(platform.x + platform.width, platform.y + platform.height);
                        ctx.closePath();
                        ctx.fill();
                    } else if (platform.isGolden) {
                        ctx.fillStyle = '#3FE1B0';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    } else {
                        ctx.fillStyle = '#1E293B';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                });

                movingPlatforms.forEach(platform => {
                    ctx.fillStyle = '#3FE1B0';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                });

                powerups.forEach(powerup => {
                    const sprite = sprites.get(powerup.type);
                    if (sprite && sprite.complete && sprite.naturalHeight !== 0) {
                        ctx.drawImage(sprite, powerup.x, powerup.y, powerup.width, powerup.height);
                    } else {
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(powerup.x, powerup.y, powerup.width, powerup.height);
                        console.warn(`Sprite for ${powerup.type} not found or not loaded`);
                    }
                });

                if (blastEffectActive) {
                    ctx.beginPath();
                    ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 200, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                drawParticles(ctx);

                if (comboCounter > 1) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Orbitron, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Combo: ${comboCounter}x`, canvas.width / 2, 30);
                }
            }
            updateWindIndicator();
            resetScreenShake(ctx);
        }

        function drawGameOver() {
            if (!ctx) {
                console.error('Canvas context not initialized in drawGameOver');
                return;
            }
            ctx.fillStyle = 'rgba(22, 33, 62, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#3FE1B0';
            ctx.font = 'bold 48px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);

            ctx.font = '24px Orbitron, sans-serif';
            ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 10);

            ctx.font = '20px Orbitron, sans-serif';
            ctx.fillText('Enter your name to save your score', canvas.width / 2, canvas.height / 2 + 50);

            document.getElementById('startButton').style.display = 'block';
        }

        function resetGame() {
            console.log('Resetting game...');
            document.dispatchEvent(new Event('gameReset'));
            
            gameRunning = true;
            gameOver = false;
            lastTime = performance.now();
            blocksClimbed = 0;
            requestAnimationFrame(gameLoop);
            updateBlockCounter();

            for (const type of powerUpTypes) {
                const powerupItem = document.getElementById(`powerup-${type}`);
                if (powerupItem) {
                    powerupItem.classList.remove('active');
                    const timerElement = powerupItem.querySelector('.powerup-timer');
                    if (timerElement) {
                        timerElement.textContent = '';
                    }
                }
            }
            player.x = 375;
            player.y = 530;
            player.velocityY = 0;
            player.velocityX = 0;
            player.isJumping = false;
            player.jumpCount = 0;
            powerups = [];
            platforms = [];
            bottomPlatform = {
                x: 0,
                y: 580,
                width: 800,
                height: 20,
                isSafe: true
            };
            score = 0;
            comboCounter = 0;
            comboTimer = 0;
            blastEffectActive = false;
            blastEffectTimer = 0;
            isPlayerOnSafePlatform = false;
            hasLeftGround = false;
            debugInfo.totalBlocksClimbed = 0;
            difficultyLevel = 1;
            adjustGameParameters();
            initGame();
        }

        function initEventListeners() {
            window.addEventListener('keydown', event => {
                keys[event.key] = true;
            });
            window.addEventListener('keyup', event => {
                keys[event.key] = false;
            });
            document.getElementById('start-game-button').addEventListener('click', startGame);
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
        }

        window.addEventListener('load', async () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            await preloadSounds();
            initWeb3();
            initEventListeners();

            document.getElementById('purchaseTriesButton').addEventListener('click', async () => {
                try {
                    await purchaseGameTries();
                    alert('Game tries purchased successfully.');
                } catch (error) {
                    alert('Failed to purchase game tries.');
                    console.error(error);
                }
            });

            document.getElementById('getTriesButton').addEventListener('click', async () => {
                try {
                    const tries = await getGameTries();
                    alert(`You have ${tries} game tries left.`);
                } catch (error) {
                    alert('Failed to get game tries.');
                    console.error(error);
                }
            });

            document.getElementById('highscoresButton').addEventListener('click', async () => {
                try {
                    const highscores = await getHighscores();
                    updateHighscoreTable(highscores);
                } catch (error) {
                    alert('Failed to get highscores.');
                    console.error(error);
                }
            });

            document.getElementById('updateScoreButton').addEventListener('click', async () => {
                try {
                    await updateHighscore(score);
                    const highscores = await getHighscores();
                    updateHighscoreTable(highscores);
                } catch (error) {
                    alert('Failed to update highscore.');
                    console.error(error);
                }
            });

            console.log('Loading all sprites...');
            try {
                await Promise.all(
                    Object.entries(powerupImages).map(([name, fileName]) =>
                        loadSprite(name, fileName).then(({ key, image }) => {
                            sprites.set(key, image);
                        })
                    )
                );
                console.log('All sprites loaded successfully');
            } catch (error) {
                console.error('Error loading sprites:', error);
            }

            try {
                const playerSprite = await loadSprite('player', 'player.png');
                sprites.set(playerSprite.key, playerSprite.image);
                console.log('Player sprite loaded successfully');
            } catch (error) {
                console.error('Error loading player sprite:', error);
            }

            initGame();
        });

        function updateWindIndicator() {
            const windIndicator = document.getElementById('windIndicator');
            if (windIndicator) {
                if (wind.speed > 0) {
                    windIndicator.textContent = wind.direction > 0 ? '→' : '←';
                    windIndicator.style.color = wind.speed > 30 ? 'rgb(255, 0, 0)' : 'rgb(255, 255, 255)';
                    windIndicator.style.left = wind.direction > 0 ? 'calc(100% - 80px)' : '20px';
                    windIndicator.style.display = 'block';
                } else {
                    windIndicator.style.display = 'none';
                }
            } else {
                console.error('Wind indicator element not found');
            }
        }

        function showNameForm() {
            const nameForm = document.getElementById('nameForm');
            if (nameForm) {
                nameForm.style.display = 'block';
            } else {
                console.error('Name form element not found');
            }
        }

        function updateHighscoreTable(highscores) {
            const highscoreBody = document.getElementById('highscoreBody');
            if (highscoreBody) {
                highscoreBody.innerHTML = highscores.map((score, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${score.name}</td>
                        <td>${score.score}</td>
                        <td>${score.blocks}</td>
                    </tr>
                `).join('');
            } else {
                console.error('Highscore body element not found');
            }
        }
    </script>
</body>
</html>
