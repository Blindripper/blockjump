<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockJump</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        body {
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            color: #e94560;
        }
        #gameWrapper {
            display: flex;
            justify-content: space-between;
            width: 1200px;
        }
        #highscoreSection {
            width: 200px;
            margin-right: 20px;
        }
        #gameContainer {
            position: relative;
        }
        #powerupSection {
            width: 200px;
            margin-left: 20px;
        }
        #gameCanvas {
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        #floorCounter {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            text-align: center;
        }
        #startButton, #soundToggle {
            font-size: 24px;
            padding: 10px 20px;
            background-color: #e94560;
            color: #16213e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            margin: 10px;
        }
        #startButton:hover, #soundToggle:hover {
            background-color: #ff6b6b;
            transform: scale(1.05);
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #achievementPopup {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 215, 0, 0.8);
            color: #16213e;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            display: none;
        }
        #windIndicator {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
        }
        .section-title {
            font-size: 20px;
            margin-bottom: 10px;
            text-align: center;
        }
        .powerup-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .powerup-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
        }
        .powerup-description {
            font-size: 14px;
        }
        #highscoreTable {
            width: 100%;
            border-collapse: collapse;
        }
        #highscoreTable th, #highscoreTable td {
            border: 1px solid #e94560;
            padding: 5px;
            text-align: center;
        }
        #nameForm {
            margin-top: 10px;
            display: none;
        }
        #nameInput {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
        }
        #submitScore {
            width: 100%;
            padding: 5px;
            background-color: #e94560;
            color: #16213e;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="highscoreSection">
            <div class="section-title">Highscores</div>
            <table id="highscoreTable">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="highscoreBody"></tbody>
            </table>
            <form id="nameForm">
                <input type="text" id="nameInput" placeholder="Enter your name" maxlength="10" required>
                <button type="submit" id="submitScore">Submit Score</button>
            </form>
        </div>
        <div id="gameContainer">
            <div id="floorCounter">Tezos Marketcap: 0000000000</div>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="achievementPopup"></div>
            <div id="windIndicator"></div>
            <div id="controls">
                <button id="startButton">Start Game</button>
                <button id="soundToggle">Sound: On</button>
            </div>
        </div>
        <div id="powerupSection">
            <div class="section-title">Powerups</div>
            <!-- Powerup descriptions will be dynamically added here -->
        </div>
    </div>
    <script>
    // Define base URL for the GitHub repository
    const repoBaseUrl = 'https://raw.githubusercontent.com/Blindripper/blockjump/main/';

    // Define specific URLs for different resource types
    const soundUrl = `${repoBaseUrl}sound/`;
    const picsUrl = `${repoBaseUrl}pics/`;

    const BLAST_POWERUP_DURATION = 20; // Duration in seconds

    // Global canvas variables
    let canvas, ctx;

    let sprites = new Map();

    let blastEffectActive = false;
    let blastEffectTimer = 0;

    const POWERUP_MESSAGE_DURATION = 1000; // Duration in milliseconds

    function showPowerupMessage(message) {
    const canvas = document.getElementById('gameCanvas');
    const canvasRect = canvas.getBoundingClientRect();

    const popup = document.createElement('div');
    popup.textContent = message;
    popup.style.position = 'absolute';
    popup.style.top = `${canvasRect.top + canvas.height / 2}px`;
    popup.style.left = `${canvasRect.left + canvas.width / 2}px`;
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.backgroundColor = 'rgba(255, 215, 0, 0.8)';
    popup.style.color = '#16213e';
    popup.style.padding = '10px 20px';
    popup.style.borderRadius = '5px';
    popup.style.fontFamily = 'Orbitron, sans-serif';
    popup.style.fontSize = '18px';
    popup.style.zIndex = '1000';
    popup.style.textAlign = 'center';
    popup.style.whiteSpace = 'nowrap';
    popup.style.pointerEvents = 'none';
    document.body.appendChild(popup);

    setTimeout(() => {
        popup.style.transition = 'opacity 0.5s';
        popup.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(popup);
        }, 500);
    }, POWERUP_MESSAGE_DURATION);
}


    // Debug information
    let debugInfo = {
        totalBlocksClimbed: 0,
        blocksUntilNextPowerup: 0,
        powerupsGenerated: 0,
        activePowerups: 0
    };

    // Highscore system
    let highscores = [];

    // Powerup descriptions
    const powerupDescriptions = {
        bitcoin: { points: 250, effect: "Fly for 5 seconds" },
        solana: { points: 0, effect: "Game Over" },
        ethereum: { points: 250, effect: "Shrinks platforms for 5 seconds" },
        etherLink: { points: 1000, effect: "Instant boost to score" },
        greenTezos: { points: 250, effect: "Allows triple jump for 10 seconds" },
        blast: { points: 250, effect: "Auto-collects nearby Etherlink coins" },
        mintTezos: { points: 250, effect: "Slows down game for 10 seconds" }
    };

    // Powerup image mapping
    const powerupImages = {
        bitcoin: 'bitcoin.png',
        solana: 'solana.png',
        ethereum: 'ethereum1.png',
        etherLink: 'Etherlink.png',
        greenTezos: 'doubleJump.png',
        blast: 'magneticCoin.png',
        mintTezos: 'slowMotion.png'
    };

    // Sprite loading with error handling and logging
    function loadSprite(name, fileName) {
        return new Promise((resolve, reject) => {
            const sprite = new Image();
            sprite.onload = () => {
                console.log(`${name} sprite loaded successfully`);
                resolve({ key: name, image: sprite });
            };
            sprite.onerror = () => {
                console.error(`Failed to load ${name} sprite from ${picsUrl}${fileName}`);
                reject(new Error(`Failed to load ${name} sprite`));
            };
            sprite.src = `${picsUrl}${fileName}`;
        });
    }

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
            img.src = src;
        });
    }

    // Background images array declaration
    const backgrounds = Array.from({ length: 16 }, (_, i) => ({
        image: null,
        floorStart: i * 100,
        color: `hsl(${i * 20}, 70%, 20%)` // Fallback color
    }));

    // Load all background images
    Promise.all(backgrounds.map((bg, index) => 
        loadImage(`${picsUrl}bg${index + 1}.jpg`)
            .then(img => { bg.image = img; })
            .catch(error => { 
                console.error(error);
                // Keep the fallback color
            })
    )).then(() => {
        console.log("All background images loaded (or failed gracefully)");
    }).catch(error => {
        console.error("Error in background loading:", error);
    });

    // Stage names
    const stageNames = [
        { name: "Athens", start: 0, end: 999 },
        { name: "Babylon", start: 1000, end: 1999 },
        { name: "Carthage", start: 2000, end: 2999 },
        { name: "Delphi", start: 3000, end: 3999 },
        { name: "Edo", start: 4000, end: 4999 },
        { name: "Florence", start: 5000, end: 5999 },
        { name: "Granada", start: 6000, end: 6999 },
        { name: "Hangzhou", start: 7000, end: 7999 },
        { name: "Ithaca", start: 8000, end: 8999 },
        { name: "Jakarta", start: 9000, end: 9999 },
        { name: "Kathmandu", start: 10000, end: 10999 },
        { name: "Lima", start: 11000, end: 11999 },
        { name: "Mumbai", start: 12000, end: 12999 },
        { name: "Nairobi", start: 13000, end: 13999 },
        { name: "Oxford", start: 14000, end: 14999 },
        { name: "Paris", start: 15000, end: Infinity }
    ];

    // Stage name display variables
    let currentStageName = "";
    let stageNameOpacity = 0;
    let stageNameTimer = 0;

    // Game constants
    const JUMP_VELOCITY = -800;
    const GRAVITY = 2000;
    let PLATFORM_SPEED = 150;

    // Game variables
    let player = {
        x: 375,
        y: 530,
        width: 50,
        height: 50,
        speed: 500,
        velocityY: 0,
        velocityX: 0,
        isJumping: false,
        jumpCount: 0,
        maxJumps: 2,
        canJump: true
    };

    let platforms = [];
    let bottomPlatform = {
        x: 0,
        y: 580,
        width: 800,
        height: 20,
        isSafe: true
    };
    let score = 0;
    let keys = {};
    let gameRunning = false;
    let gameOver = false;
    let hasLeftGround = false;
    let currentBackgroundIndex = 0;
    let fadeAlpha = 0;
    let isFading = false;
    let nextBottomPlatformScore = 100;
    let isPlayerOnSafePlatform = false;

    // New game elements
    let comboCounter = 0;
    let comboTimer = 0;
    let movingPlatforms = [];
    let wind = { speed: 0, direction: 1 }; // 1 for right, -1 for left
    let achievements = {
        highJumper: { achieved: false, requirement: 10000 },
        comboMaster: { achieved: false, requirement: 10 },
        cryptoWhale: { achieved: false, requirement: 100000 }
    };

    // Powerup variables
    let powerups = [];
    let powerupActive = false;
    let powerupTimer = 0;
    let blocksUntilNextPowerup = Math.floor(Math.random() * 10) + 5; // Increased drop rate: 5-15 blocks
    let ethereumEffectActive = false;
    let ethereumEffectTimer = 0;
    let originalPlatformWidth = 120; // Store the original platform width
    let spikeBlockProbability = 0.05; // Initial 5% chance for spike blocks

    const powerUpTypes = ['bitcoin', 'solana', 'ethereum', 'etherLink', 'greenTezos', 'blast', 'mintTezos'];

    // Sound system
    const sounds = {
        jump: new Audio(`${soundUrl}jump.wav`),
        powerup: new Audio(`${soundUrl}powerup.mp3`),
        gameOver: new Audio(`${soundUrl}gameover.mp3`),
        background: new Audio(`${soundUrl}main.mp3`)
    };

    let isSoundOn = true;

    function toggleSound() {
        isSoundOn = !isSoundOn;
        soundToggle.textContent = `Sound: ${isSoundOn ? 'On' : 'Off'}`;
        if (isSoundOn) {
            sounds.background.play();
        } else {
            sounds.background.pause();
        }
    }

    function playSound(soundName) {
        if (isSoundOn && sounds[soundName]) {
            sounds[soundName].currentTime = 0;
            sounds[soundName].play().catch(error => console.error("Error playing sound:", error));
        }
    }

    function startBackgroundMusic() {
        if (isSoundOn) {
            sounds.background.loop = true;
            sounds.background.play().catch(error => console.error("Error playing background music:", error));
        }
    }

    function stopBackgroundMusic() {
        sounds.background.pause();
        sounds.background.currentTime = 0;
    }

    function preloadSounds() {
        return Promise.all(Object.values(sounds).map(audio => {
            return new Promise((resolve, reject) => {
                audio.addEventListener('canplaythrough', resolve, { once: true });
                audio.addEventListener('error', reject);
                audio.load();
            });
        }));
    }

    // Particle system
    let particles = [];

    function Particle(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = Math.random() * 2 - 1;
        this.vy = Math.random() * -2 - 1;
        this.alpha = 1;
        this.color = color;
    }

    Particle.prototype.update = function(dt) {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= dt * 2;
    };

    Particle.prototype.draw = function(ctx) {
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 2, 2);
        ctx.globalAlpha = 1;
    };

    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function updatePowerups(dt) {
    powerups.forEach((powerup, index) => {
        powerup.y += PLATFORM_SPEED * dt;

        // Check for collision with player
        if (checkCollision(player, powerup)) {
            applyPowerupEffect(powerup.type);
            powerups.splice(index, 1); // Remove the collected powerup
            return;
        }

        // Check if the powerup has gone off-screen
        if (powerup.y > canvas.height) {
            powerups.splice(index, 1); // Remove off-screen powerup
        }

        // Auto-collect etherLink powerups when blast effect is active
        if (blastEffectActive && powerup.type === 'etherLink') {
            applyPowerupEffect(powerup.type);
            powerups.splice(index, 1); // Remove the collected powerup
        }
    });
}




    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt);
            if (particles[i].alpha <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    function updateCombo(dt) {
    if (comboTimer > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
            comboCounter = 0;
        }
    }
}
function updateWind(dt) {
    // Randomly change wind every few seconds
    if (Math.random() < 0.01) { // 1% chance each frame to change wind
        wind.speed = Math.random() * 50; // Wind speed up to 50
        wind.direction = Math.random() < 0.5 ? -1 : 1; // Randomly choose left or right
    }

    // Apply wind effect to player
    player.x += wind.speed * wind.direction * dt;
    
    // Keep player within bounds
    player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

    // Update wind indicator
    updateWindIndicator();
}

function updateAchievements() {
    if (!achievements.highJumper.achieved && score >= achievements.highJumper.requirement) {
        achievements.highJumper.achieved = true;
        showAchievement("High Jumper");
    }
    if (!achievements.comboMaster.achieved && comboCounter >= achievements.comboMaster.requirement) {
        achievements.comboMaster.achieved = true;
        showAchievement("Combo Master");
    }
    if (!achievements.cryptoWhale.achieved && score >= achievements.cryptoWhale.requirement) {
        achievements.cryptoWhale.achieved = true;
        showAchievement("Crypto Whale");
    }
}

function showAchievement(name) {
    const achievementPopup = document.getElementById('achievementPopup');
    if (achievementPopup) {
        achievementPopup.textContent = `Achievement Unlocked: ${name}`;
        achievementPopup.style.display = 'block';
        setTimeout(() => {
            achievementPopup.style.display = 'none';
        }, 3000);
    } else {
        console.error('Achievement popup element not found');
    }
}

function incrementCombo() {
    comboCounter++;
    comboTimer = 5; // Set combo timer to 5 seconds
    if (comboCounter > 1) {
        score += comboCounter * 10; // Bonus points for combo
    }
}

    function drawParticles(ctx) {
        particles.forEach(particle => particle.draw(ctx));
    }

    // Move powerups and check for collision
debugInfo.activePowerups = powerups.length;

for (let i = powerups.length - 1; i >= 0; i--) {
    powerups[i].y += PLATFORM_SPEED * dt;
    if (powerups[i].y > canvas.height) {
        powerups.splice(i, 1);
        console.log("Powerup removed (out of bounds)");
    } else if (player.x < powerups[i].x + powerups[i].width &&
               player.x + player.width > powerups[i].x &&
               player.y < powerups[i].y + powerups[i].height &&
               player.y + player.height > powerups[i].y) {
        applyPowerUpEffect(powerups[i].type);  // This line causes the error
        powerups.splice(i, 1);
        incrementCombo();
    }
}




function applyPowerUpEffect(powerupType) {
    let message = '';
    
    switch (powerupType) {
        case 'bitcoin':
            powerupActive = true;
            powerupTimer = 5; // 5 seconds of flight
            player.velocityY = JUMP_VELOCITY * 1.5; // Boost the player up
            message = 'Bitcoin: Fly 5s!';
            break;
        
        case 'blast':
            blastEffectActive = true;
            blastEffectTimer = BLAST_POWERUP_DURATION;
            message = `Blast:EtherLink Autocollect!`;
            break;
        
            case 'solana':
            gameOver = true;
            gameRunning = false;
            playSound('gameOver');
            message = 'Solana: Game Over!';
            break;
        case 'ethereum':
            ethereumEffectActive = true;
            ethereumEffectTimer = 5; // 5 seconds of shrunk platforms
            platforms.forEach(platform => {
                platform.width *= 0.5; // Shrink platforms
            });
            message = 'Ethereum: Shrunk';
            break;
        case 'etherLink':
            score += 1000; // Instant boost to score
            message = 'EtherLink: +1000!';
            break;
        case 'greenTezos':
            player.maxJumps = 3; // Allow triple jump
            setTimeout(() => { player.maxJumps = 2; }, 10000); // Reset after 10 seconds
            message = 'Green Tezos: TripleJump 10s!';
            break;
        case 'mintTezos':
            PLATFORM_SPEED *= 0.5; // Slow down game
            setTimeout(() => { PLATFORM_SPEED *= 2; }, 10000); // Reset after 10 seconds
            message = 'Mint Tezos: Slowdon 10s!';
            break;
    }
    playSound('powerup');
    score += powerupDescriptions[powerupType].points;
    showPowerupMessage(message);
}

    // Screen shake effect
    let screenShake = {
        intensity: 0,
        duration: 0
    };

    function collectNearbyEtherlink() {
    const blastRadius = 3800; // Adjust this value to change the collection range
    let collectedCount = 0;

    for (let i = powerups.length - 1; i >= 0; i--) {
        if (powerups[i].type === 'etherLink') {
            const dx = powerups[i].x - (player.x + player.width / 2);
            const dy = powerups[i].y - (player.y + player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= blastRadius) {
                // Collect this Etherlink powerup
                score += powerupDescriptions['etherLink'].points;
                createParticles(powerups[i].x, powerups[i].y, 10, '#00FFFF');
                powerups.splice(i, 1);
                collectedCount++;
            }
        }
    }

    if (collectedCount > 0) {
        showPowerupMessage(`Collected ${collectedCount} EtherLink powerup${collectedCount > 1 ? 's' : ''}!`);
    }
}

    function triggerScreenShake(intensity, duration) {
        screenShake.intensity = intensity;
        screenShake.duration = duration;
    }

    function updateScreenShake(dt) {
        if (screenShake.duration > 0) {
            screenShake.duration -= dt;
            if (screenShake.duration <= 0) {
                screenShake.intensity = 0;
            }
        }
    }



    function applyScreenShake(ctx) {
        if (screenShake.intensity > 0) {
            const dx = Math.random() * screenShake.intensity * 2 - screenShake.intensity;
            const dy = Math.random() * screenShake.intensity * 2 - screenShake.intensity;
            ctx.save();
            ctx.translate(dx, dy);
        }
    }

    function resetScreenShake(ctx) {
        if (screenShake.intensity > 0) {
            ctx.restore();
        }
    }

    // Dynamic difficulty system
    let difficultyLevel = 1;
    let scoreThreshold = 2500; // Increased initial threshold
    const maxDifficultyLevel = 10; // Increased max difficulty level

    function updateDifficulty() {
    const newDifficultyLevel = Math.floor(score / 2000) + 1;
    if (newDifficultyLevel > difficultyLevel) {
        difficultyLevel = newDifficultyLevel;
        adjustGameParameters();
        console.log(`Difficulty increased to level ${difficultyLevel}. New platform speed: ${PLATFORM_SPEED}`);
    }
}

    function adjustGameParameters() {
        // Adjust game parameters based on difficulty level
        PLATFORM_SPEED = 150 + (difficultyLevel - 1) * 5; // Slower speed increase
        player.speed = 500 + (difficultyLevel - 1) * 10; // Slower player speed increase
        
        // Adjust platform generation
        let platformWidthReduction = Math.min(40, (difficultyLevel - 1) * 5); // Cap the width reduction
        originalPlatformWidth = Math.max(80, 120 - platformWidthReduction);
        
        // Increase frequency of powerups and hazards more slowly
        blocksUntilNextPowerup = Math.max(5, 15 - (difficultyLevel - 1)); // Increased drop rate
        spikeBlockProbability = Math.min(0.15, 0.05 + (difficultyLevel - 1) * 0.01); // Cap at 15% chance

        // Add moving platforms
        if (difficultyLevel >= 3 && movingPlatforms.length < 2) {
            movingPlatforms.push({
                x: Math.random() * (canvas.width - 100),
                y: Math.random() * (canvas.height / 2),
                width: 100,
                height: 15,
                speed: 50 + Math.random() * 50
            });
        }

        // Increase wind probability and max speed
        if (difficultyLevel >= 5) {
            wind.speed = Math.random() * (50 + difficultyLevel * 5);
        }
    }

    function createPlatform(y) {
        if (!canvas) {
            console.error('Canvas not initialized in createPlatform');
            return null;
        }
        let platformType = Math.random();
        let platform = {
            x: Math.random() * (canvas.width - (ethereumEffectActive ? originalPlatformWidth * 0.5 : originalPlatformWidth)),
            y: y,
            width: ethereumEffectActive ? originalPlatformWidth * 0.5 : originalPlatformWidth,
            height: 15,
            isGolden: (score + platforms.length) % 15 === 0
        };

        if (platformType < spikeBlockProbability) {
            platform.isSpike = true;
        }

        return platform;
    }

    function createPowerup(y) {
        if (!canvas) {
            console.error('Canvas not initialized in createPowerup');
            return null;
        }
        const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
        debugInfo.powerupsGenerated++;
        console.log(`Powerup generated. Total: ${debugInfo.powerupsGenerated}, Type: ${type}`);
        return {
            x: Math.random() * (canvas.width - 30),
            y: y,
            width: 30,
            height: 30,
            type: type
        };
    }

    function initGame() {
        if (!canvas || !ctx) {
            console.error('Canvas not initialized in initGame');
            return;
        }
        // Initialize platforms
        platforms = [];
        for (let i = 0; i < 7; i++) {
            platforms.push(createPlatform(canvas.height - (i + 2) * 100));
        }
        nextBottomPlatformScore = 100;
        bottomPlatform.isSafe = true;
        isPlayerOnSafePlatform = false;

        // Reset blast effect variables
    blastEffectActive = false;
    blastEffectTimer = 0;

        
    // Restart background music
    startBackgroundMusic();
    }

    function updateBackground() {
        let newBackgroundIndex = Math.min(Math.floor(score / 1000), backgrounds.length - 1);
        if (newBackgroundIndex !== currentBackgroundIndex) {
            currentBackgroundIndex = newBackgroundIndex;
            isFading = true;
            fadeAlpha = 0;
            
            // Update stage name when background changes
            updateStageName();
        }
    }

    function updateStageName() {
        const currentStage = stageNames.find(stage => score >= stage.start && score <= stage.end) || stageNames[stageNames.length - 1];
        if (currentStage && currentStage.name !== currentStageName) {
            currentStageName = currentStage.name;
            stageNameOpacity = 1;
            stageNameTimer = 3; // 3 seconds display time
        }
    }


    function update(dt) {
        if (!gameRunning || gameOver) return;

        if (blastEffectTimer > 0) {
        blastEffectTimer -= dt;
        if (blastEffectTimer <= 0) {
            blastEffectTimer = 0;
        }
    }

        // Add a safety check to prevent infinite loops
        if (debugInfo.totalBlocksClimbed > 10000) {
            console.error("Game loop safety limit reached");
            gameOver = true;
            gameRunning = false;
            return;
        }

        updateDifficulty();
        updateScreenShake(dt);
        updateParticles(dt);
        updateCombo(dt);
        updateWind(dt);
        updateAchievements();

        // Update stage name
        if (stageNameTimer > 0) {
            stageNameTimer -= dt;
            if (stageNameTimer <= 0) {
                stageNameOpacity = Math.max(0, stageNameOpacity - dt);
            }
        }

        // Player movement
        let moveSpeed = player.speed;

        if (keys.ArrowLeft) {
            player.velocityX = -moveSpeed;
        } else if (keys.ArrowRight) {
            player.velocityX = moveSpeed;
        } else {
            player.velocityX *= 0; // Reduced from 0.9 for quicker deceleration
        }

        player.x += player.velocityX * dt;

        // Keep player within bounds
        player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

        // Jumping
        if (keys.ArrowUp && player.jumpCount < player.maxJumps && player.canJump) {
            player.velocityY = JUMP_VELOCITY;
            player.isJumping = true;
            player.jumpCount++;
            player.canJump = false;
            if (!hasLeftGround) {
                hasLeftGround = true;
            }
            if (isPlayerOnSafePlatform) {
                isPlayerOnSafePlatform = false;
            }
            createParticles(player.x + player.width / 2, player.y + player.height, 10, '#e94560');
            playSound('jump');
        }

        // Reset canJump when the up arrow key is released
        if (!keys.ArrowUp) {
            player.canJump = true;
        }

        // Powerup jumping (unlimited jumps)
        if (powerupActive && keys.ArrowUp && player.canJump) {
            player.velocityY = JUMP_VELOCITY;
            player.canJump = false;
            if (!hasLeftGround) {
                hasLeftGround = true;
            }
            if (isPlayerOnSafePlatform) {
                isPlayerOnSafePlatform = false;
            }
            createParticles(player.x + player.width / 2, player.y + player.height, 10, '#FFD700');
            playSound('jump');
        }

        // Apply gravity
        player.velocityY += GRAVITY * dt;
        player.y += player.velocityY * dt;

        // Handle platform collisions
        let onPlatform = false;
        if (player.velocityY >= 0) {
            if (player.y + player.height > bottomPlatform.y && 
                player.y + player.height < bottomPlatform.y + bottomPlatform.height &&
                bottomPlatform.y < canvas.height) {
                player.y = bottomPlatform.y - player.height;
                player.velocityY = 0;
                player.isJumping = false;
                player.jumpCount = 0;
                if (bottomPlatform.isSafe) {
                    isPlayerOnSafePlatform = true;
                }
                createParticles(player.x + player.width / 2, player.y + player.height, 5, '#4CAF50');
                onPlatform = true;
            }

            platforms.forEach(platform => {
                if (player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x) {
                    if (platform.isSpike) {
                        gameOver = true;
                        gameRunning = false;
                        playSound('gameOver');
                    } else {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.isJumping = false;
                        player.jumpCount = 0;
                        onPlatform = true;

                        if (platform.isGolden) {
                            player.velocityY = JUMP_VELOCITY * 1.5; // 1.5x jump height for golden platforms
                            score += 15;
                            triggerScreenShake(5, 0.3);
                            createParticles(player.x + player.width / 2, player.y + player.height, 15, '#FFD700');
                            playSound('powerup');
                        } else {
                            createParticles(player.x + player.width / 2, player.y + player.height, 5, '#0f3460');
                        }
                    }
                }
            });

            // Check collision with moving platforms
            movingPlatforms.forEach(platform => {
                if (player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x) {
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.jumpCount = 0;
                    onPlatform = true;
                    createParticles(player.x + player.width / 2, player.y + player.height, 5, '#4CAF50');
                }
            });
        }

        if (!onPlatform) {
            player.isJumping = true;
        }

        // Move platforms and generate new ones
        if (hasLeftGround && !isPlayerOnSafePlatform) {
            platforms.forEach((platform, index) => {
                platform.y += PLATFORM_SPEED * dt;
                
                if (platform.y > canvas.height) {
                    score++;
                    debugInfo.totalBlocksClimbed++;
                    floorCounter.textContent = `Tezos Marketcap: ${score.toString().padStart(10, '0')}`;
                    platforms[index] = createPlatform(0);
                    
                    updateBackground();

                    // Check if it's time to generate a new powerup
                    if (debugInfo.totalBlocksClimbed >= blocksUntilNextPowerup) {
                        powerups.push(createPowerup(0));
                        blocksUntilNextPowerup = debugInfo.totalBlocksClimbed + Math.floor(Math.random() * 10) + 5; // Increased drop rate
                        console.log(`Powerup generated. Next at ${blocksUntilNextPowerup}`);
                    }
                }
            });

            // Move bottom platform
            bottomPlatform.y += PLATFORM_SPEED * dt;

            // Create new bottom platform every 100 floors
            if (score >= nextBottomPlatformScore) {
                bottomPlatform = {
                    x: 0,
                    y: 0,
                    width: 800,
                    height: 20,
                    isSafe: true
                };
                nextBottomPlatformScore += 100;
            }

            // Move and update moving platforms
            movingPlatforms.forEach(platform => {
                platform.x += platform.speed * dt;
                platform.y += PLATFORM_SPEED * dt;
                if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                    platform.speed *= -1;
                }
                if (platform.y > canvas.height) {
                    platform.y = 0;
                    platform.x = Math.random() * (canvas.width - platform.width);
                }
            });
        }

        // Keep player in view
        if (player.y < 300 && !isPlayerOnSafePlatform) {
            let diff = 300 - player.y;
            player.y = 300;
            platforms.forEach(platform => {
                platform.y += diff;
            });
            movingPlatforms.forEach(platform => {
                platform.y += diff;
            });
            bottomPlatform.y += diff;
        }

        // Game over condition
        if (player.y > canvas.height) {
            if (!bottomPlatform.isSafe || player.y > bottomPlatform.y + bottomPlatform.height) {
                gameOver = true;
                gameRunning = false;
                playSound('gameOver');
                showNameForm();
            }
        }

        // Reset bottom platform safety when player leaves it
        if (player.y + player.height < bottomPlatform.y) {
            bottomPlatform.isSafe = false;
            isPlayerOnSafePlatform = false;
        }

        // Move powerups and check for collision
        debugInfo.activePowerups = powerups.length;
        
        for (let i = powerups.length - 1; i >= 0; i--) {
            powerups[i].y += PLATFORM_SPEED * dt;
            if (powerups[i].y > canvas.height) {
                powerups.splice(i, 1);
                console.log("Powerup removed (out of bounds)");
            } else if (player.x < powerups[i].x + powerups[i].width &&
                       player.x + player.width > powerups[i].x &&
                       player.y < powerups[i].y + powerups[i].height &&
                       player.y + player.height > powerups[i].y) {
                applyPowerUpEffect(powerups[i].type);
                powerups.splice(i, 1);
                incrementCombo();
            }
        }

        // Apply wind effect to player
        player.x += wind.speed * wind.direction * dt;
        player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

        // Powerup timer
        if (powerupActive) {
            powerupTimer -= dt;
            if (powerupTimer <= 0) {
                powerupActive = false;
            }
        }

        // Ethereum effect timer
        if (ethereumEffectActive) {
            ethereumEffectTimer -= dt;
            if (ethereumEffectTimer <= 0) {
                ethereumEffectActive = false;
                // Reset platform sizes
                platforms.forEach(platform => {
                    platform.width = originalPlatformWidth;
                });
            }
        }

        // Update wind indicator
        updateWindIndicator();

        // Add debug info display
        console.log(`Debug: Blocks: ${debugInfo.totalBlocksClimbed}, Powerups: ${powerups.length}, Difficulty: ${difficultyLevel}`);
    }

    function draw() {
        if (!ctx) {
            console.error('Canvas context not initialized in draw');
            return;
        }
        applyScreenShake(ctx);

        // Draw current background
        const currentBg = backgrounds[currentBackgroundIndex];
        if (currentBg.image && currentBg.image.complete && currentBg.image.naturalHeight !== 0) {
            ctx.drawImage(currentBg.image, 0, 0, canvas.width, canvas.height);
        } else {
            // Use fallback color if image not loaded or invalid
            ctx.fillStyle = currentBg.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Draw stage name
        if (stageNameOpacity > 0) {
            ctx.globalAlpha = stageNameOpacity;
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 48px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(currentStageName, canvas.width / 2, canvas.height / 2);
            ctx.globalAlpha = 1;
        }

        // If fading, draw the next background with increasing opacity
        if (isFading) {
            ctx.globalAlpha = fadeAlpha;
            const nextBg = backgrounds[Math.min(currentBackgroundIndex + 1, backgrounds.length - 1)];
            if (nextBg.image && nextBg.image.complete && nextBg.image.naturalHeight !== 0) {
                ctx.drawImage(nextBg.image, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = nextBg.color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.globalAlpha = 1;
            
            fadeAlpha += 0.02;
            if (fadeAlpha >= 1) {
                isFading = false;
            }
        }

        if (gameOver) {
            drawGameOver();
        } else {
            // Draw bottom platform
            ctx.fillStyle = bottomPlatform.isSafe ? '#4CAF50' : '#0f3460';
            ctx.fillRect(bottomPlatform.x, bottomPlatform.y, bottomPlatform.width, bottomPlatform.height);

            // Draw platforms
            platforms.forEach(platform => {
                if (platform.isSpike) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.moveTo(platform.x, platform.y + platform.height);
                    ctx.lineTo(platform.x + platform.width / 2, platform.y);
                    ctx.lineTo(platform.x + platform.width, platform.y + platform.height);
                    ctx.closePath();
                    ctx.fill();
                } else if (platform.isGolden) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                } else {
                    ctx.fillStyle = '#0f3460';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                }
            });

            // Draw moving platforms
            movingPlatforms.forEach(platform => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Draw powerups
            powerups.forEach(powerup => {
                const sprite = sprites.get(powerup.type);
                if (sprite && sprite.complete && sprite.naturalHeight !== 0) {
                    ctx.drawImage(sprite, powerup.x, powerup.y, powerup.width, powerup.height);
                } else {
                    // Draw a colored rectangle as a fallback
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(powerup.x, powerup.y, powerup.width, powerup.height);
                    console.warn(`Sprite for ${powerup.type} not found or not loaded`);
                }
            });

            // Draw blast radius indicator if active
    if (blastEffectActive) {
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 200, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
            // Draw player
            const playerSprite = sprites.get('player');
            if (playerSprite && playerSprite.complete && playerSprite.naturalHeight !== 0) {
                if (powerupActive) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.restore();
                }
                ctx.drawImage(playerSprite, player.x, player.y, player.width, player.height);
            } else {
                // Draw a colored rectangle as a fallback for the player
                ctx.fillStyle = powerupActive ? 'yellow' : 'blue';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Draw particles
            drawParticles(ctx);

            // Draw combo counter
            if (comboCounter > 1) {
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 24px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Combo: ${comboCounter}x`, canvas.width / 2, 30);
            }
        }

        resetScreenShake(ctx);
    }

    function drawGameOver() {
        if (!ctx) {
            console.error('Canvas context not initialized in drawGameOver');
            return;
        }
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#e94560';
        ctx.font = 'bold 48px Orbitron, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);

        ctx.font = '24px Orbitron, sans-serif';
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 10);

        ctx.font = '20px Orbitron, sans-serif';
        ctx.fillText('Enter your name to save your score', canvas.width / 2, canvas.height / 2 + 50);

        startButton.style.display = 'block';
    }

    let lastTime = 0;
    const fixedDeltaTime = 1 / 60; // 60 FPS
    let accumulator = 0;

    function gameLoop(currentTime) {
        try {
            if (lastTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                accumulator += deltaTime;

                while (accumulator >= fixedDeltaTime) {
                    update(fixedDeltaTime);
                    accumulator -= fixedDeltaTime;
                }
            }

            draw();
            lastTime = currentTime;
            requestAnimationFrame(gameLoop);
        } catch (error) {
            console.error("An error occurred in the game loop:", error);
            gameOver = true;
            gameRunning = false;
            drawGameOver();
        }
    }

    function resetGame() {
        if (!canvas || !ctx) {
            console.error('Canvas not initialized in resetGame');
            return;
        }
        player.x = 375;
        player.y = 530;
        player.velocityY = 0;
        player.velocityX = 0;
        player.isJumping = false;
        player.jumpCount = 0;
        player.canJump = true;
        player.maxJumps = 2;
        bottomPlatform = {
            x: 0,
            y: 580,
            width: 800,
            height: 20,
            isSafe: true
        };
        score = 0;
        gameOver = false;
        hasLeftGround = false;
        currentBackgroundIndex = 0;
        isFading = false;
        fadeAlpha = 0;
        floorCounter.textContent = 'Tezos Marketcap: 0000000000';
        nextBottomPlatformScore = 100;
        isPlayerOnSafePlatform = false;
        powerups = [];
        powerupActive = false;
        powerupTimer = 0;
        blocksUntilNextPowerup = Math.floor(Math.random() * 10) + 5; // Increased drop rate
        ethereumEffectActive = false;
        ethereumEffectTimer = 0;
        particles = [];
        difficultyLevel = 1;
        scoreThreshold = 500;
        PLATFORM_SPEED = 150;
        player.speed = 500;
        originalPlatformWidth = 120;
        spikeBlockProbability = 0.05;
        comboCounter = 0;
        comboTimer = 0;
        movingPlatforms = [];
        wind = { speed: 0, direction: 1 };
        achievements = {
            highJumper: { achieved: false, requirement: 10000 },
            comboMaster: { achieved: false, requirement: 10 },
            cryptoWhale: { achieved: false, requirement: 100000 }
        };
        debugInfo = {
            totalBlocksClimbed: 0,
            blocksUntilNextPowerup: 0,
            powerupsGenerated: 0,
            activePowerups: 0
        };
        
        // Reset stage name
        currentStageName = "";
        stageNameOpacity = 0;
        stageNameTimer = 0;
        
        initGame();
        stopBackgroundMusic();
        startBackgroundMusic();
        
        // Force an immediate update of the stage name and wind indicator
        updateStageName();
        updateWindIndicator();
    }
    function updateWindIndicator() {
    const windIndicator = document.getElementById('windIndicator');
    if (!windIndicator) {
        console.error('Wind indicator element not found');
        return;
    }
    const arrow = wind.direction === 1 ? '→' : '←';
    const strength = Math.floor(wind.speed / 10); // Normalize wind speed to 0-5 range
    windIndicator.textContent = `${arrow}${'•'.repeat(strength)}`;
    windIndicator.style.color = `rgba(255, 255, 255, ${wind.speed / 50})`; // Fade based on wind strength
}



function showNameForm() {
    if (isTopTenScore(score)) {
        const nameForm = document.getElementById('nameForm');
        nameForm.style.display = 'block';
    } else {
        // If not a top 10 score, just reset the game
        startButton.style.display = 'block';
    }
}

function isTopTenScore(newScore) {
    if (highscores.length < 10) return true;
    return newScore > highscores[highscores.length - 1].score;
}

    function saveHighscore(name) {
        highscores.push({ name, score });
        highscores.sort((a, b) => b.score - a.score);
        highscores = highscores.slice(0, 10); // Keep only top 10 scores
        localStorage.setItem('blockjumpHighscores', JSON.stringify(highscores));
        updateHighscoreTable();
    }

    function loadHighscores() {
        const storedHighscores = localStorage.getItem('blockjumpHighscores');
        if (storedHighscores) {
            highscores = JSON.parse(storedHighscores);
        }
        updateHighscoreTable();
    }

    function updateHighscoreTable() {
        const highscoreBody = document.getElementById('highscoreBody');
        highscoreBody.innerHTML = '';
        highscores.forEach((entry, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${entry.name}</td>
                <td>${entry.score}</td>
            `;
            highscoreBody.appendChild(row);
        });
    }

    function populatePowerupDescriptions() {
        const powerupSection = document.getElementById('powerupSection');
        for (const [type, info] of Object.entries(powerupDescriptions)) {
            const powerupItem = document.createElement('div');
            powerupItem.className = 'powerup-item';
            const imageName = powerupImages[type] || `${type}.png`; // Fallback to type name if not in mapping
            powerupItem.innerHTML = `
                <img src="${picsUrl}${imageName}" alt="${type}" class="powerup-icon">
                <div class="powerup-description">
                    <strong>${type}:</strong> ${info.points} points<br>
                    ${info.effect}
                </div>
            `;
            powerupSection.appendChild(powerupItem);
        }
    }

    function initialize() {
        canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            console.error('Canvas element not found');
            return;
        }
        ctx = canvas.getContext('2d');
        const floorCounter = document.getElementById('floorCounter');
        const startButton = document.getElementById('startButton');
        const soundToggle = document.getElementById('soundToggle');
        const achievementPopup = document.getElementById('achievementPopup');
        const nameForm = document.getElementById('nameForm');

        // Load all sprites
        const spritePromises = [
            loadSprite('player', 'TezosLogo_Icon_Blue.png'),
            loadSprite('bitcoin', 'bitcoin.png'),
            loadSprite('solana', 'solana.png'),
            loadSprite('ethereum', 'ethereum1.png'),
            loadSprite('etherLink', 'Etherlink.png'),
            loadSprite('greenTezos', 'doubleJump.png'),
            loadSprite('blast', 'magneticCoin.png'),
            loadSprite('mintTezos', 'slowMotion.png')
        ];

        Promise.all(spritePromises)
            .then(loadedSprites => {
                loadedSprites.forEach(({ key, image }) => {
                    sprites.set(key, image);
                });
                
                // Keyboard input handling
                document.addEventListener('keydown', (e) => {
                    keys[e.code] = true;
                });

                document.addEventListener('keyup', (e) => {
                    keys[e.code] = false;
                });

                // Start button event listener
                startButton.addEventListener('click', () => {
                    if (canvas && ctx) {
                        resetGame();
                        gameRunning = true;
                        gameOver = false;
                        startButton.style.display = 'none';
                    } else {
                        console.error('Canvas not initialized');
                    }
                });

                // Sound toggle event listener
                soundToggle.addEventListener('click', toggleSound);

                // Name form submit event listener
                nameForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const name = document.getElementById('nameInput').value;
                    saveHighscore(name);
                    nameForm.style.display = 'none';
                    startButton.style.display = 'block';
                });

                // Populate powerup descriptions
                populatePowerupDescriptions();

                // Load highscores
                loadHighscores();

                // Preload sounds
                preloadSounds()
                    .then(() => {
                        console.log("All sounds preloaded successfully");
                        // Initialize and start the game loop
                        initGame();
                        requestAnimationFrame(gameLoop);
                    })
                    .catch(error => {
                        console.error("Error preloading sounds:", error);
                        // Initialize and start the game loop even if sound loading fails
                        initGame();
                        requestAnimationFrame(gameLoop);
                    });
            })
            .catch(error => {
                console.error("Error loading sprites:", error);
            });
    }

    document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
